# 아이템 46. 함수타입 파라미터를 갖는 함수에 inline 한정자를 붙여라

챕터 : 3부. 효율성, 7장. 비용 줄이기<br>

<br>

이번 챕터에서는 **어떤 함수가 함수타입을 받을경우 그 함수에 `inline` 한정자를 붙여라** 라고 이야기하고 있다.<br>

이 것은 조금 더 바꿔서 직설적으로 정리하면 아래와 같이 요약된다.

- **함수타입을 파라미터로 받는 함수는 `inline` 함수로 만들어라.**

<br>

그런데 책을 읽다보면, 위의 원칙은 항상 적용되는 것은 아니다. 아래의 단점들도 이야기해주고 있다.<br>

컴파일 타임에 함수 바디를 대치시키는 것이 `inline` 함수의 원리이다 보니 아래와 같은 나쁜 사례들도 이야기 해주고 있다. 

- 재귀함수가 끝나지 않을 경우
- 함수 하나가 무수히 많은 서로 다른 이름의 `inline` 함수들로 대치되는 경우

<br>

따라서 `inline` 함수는 주의해서 사용해야 한다.<br>

이런 단점에도 불구하고 `inline` 함수로 정의해야 하는 경우가 있는데, 

책에서는 이런 경우에 `inline` 함수를 도입해야 할 경우 도입했을 때의 장점을 설명해주고, 부작용을 방지할 수 있는 몇가지 방법(crossinline, noinline)들도 제시해주고 있다.<br>

<br>

반면에 inline 함수는 아래의 장점들도 가진다. 

이런 이유로 inline 함수에 대해 이번 챕터에서 자세하게 설명하고 있다. 이번 챕터를 의역으로 내린 결론은 `장점이 있는데, 신중히 사용해라` 라는 의미인 것 같다.<br>

일반함수 사용 시 함수 본문으로 점프하고, 본문의 모든 문장을 호출한 뒤에 호출했던 위치로 다시 점프하는 과정을 거친다.<br>

하지만, inline 함수를 사용해서 '함수를 호출하는 부분'을 '함수의 본문'으로 대체하면 이러한 점프가 일어나지 않는다.<br>

inline 함수를 사용하면 아래의 장점들을 가진다.

- 타입 아규먼트에 reified 한정자를 붙여서 사용할 수 있다.
  - inline 함수를 정의하면 타입 아규먼트를 reified로 사용할 수 있다.
  - reified 키워드를 통해 타입을 한정하는 것은 굉장히 유용하다.
  - 코틀린 표준 라이브러리의 filterIsInstance 도 reified를 사용하고 있다.
- 함수타입 파라미터를 가진 함수가 훨씬 빠르게 동작한다.
- 비지역(non-local) 리턴을 사용할수 있다.

<br>



# 참고자료

- [이펙티브 코틀린](https://search.shopping.naver.com/book/catalog/32487702885?query=%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%20%EC%BD%94%ED%8B%80%EB%A6%B0&NaPm=ct%3Dlc33a5ew%7Cci%3D12cc8324e975f83f5ae12bc2e2f7c2bc671c34f4%7Ctr%3Dboksl%7Csn%3D95694%7Chk%3Dfd42c6463b7c262e60c19a51c3bb48b096a11347)<br>

- [github.com/study-kopring/grammar/인라인함수.md](https://github.com/gosgjung/study-kopring/blob/main/grammar/%EC%9D%B8%EB%9D%BC%EC%9D%B8%20%ED%95%A8%EC%88%98.md)
  - 나중에 깃헙 계정을 삭제하고 새로 계설할 생각도 있지만 링크를 남겨둠

<br>



# `inline` 함수 도입을 고려하는 경우들

API 를 정의할 때 인라인 함수를 사용하는 경우는 거의 없다.<br>

또한, 하나의 인라인 함수가 다른 인라인 함수를 호출하는 경우, 코드가 기하급수적으로 많아질 수 있다.<br>

<BR>

하지만, 이런 단점을 고려 후에, `inline` 함수를 도입하는 경우들은 아래와 같다.<br>

<br>

- print 함수 처럼 매우 많이 사용되는 경우
- 코틀린 표준 라이브러리의 `filterIsInstance` 함수처럼 타입 아규먼트로 `reified` 타입을 전달받는 경우
- 함수 타입을 파라미터로 갖는 톱레벨의 함수를 정의해야 할 경우
  - e.g. 
    - 주요 컬렉션 처리 함수들 같은 헬퍼함수들 (map, filter, flatMap, joinToString)
    - 스코프 함수 (also, apply, let)
    - 톱 레벨 유틸리티 함수(repeat, run, with)

<br>



# `inline` 함수를 사용을 하면 안되는 경우

컴파일 타임에 함수 바디를 대치시키는 것이 inline 함수의 원리이다 보니 아래와 같은 나쁜 사례들도 이야기 해주고 있다. 

- 재귀함수가 끝나지 않을 경우
- 함수 하나가 무수히 많은 서로 다른 이름의 inline 함수들로 대치되는 경우

<br>

따라서 inline 함수는 주의해서 사용해야 한다.<br>

이런 단점에도 불구하고 inline 함수로 정의해야 하는 경우가 있는데, 

책에서는 이런 경우에 inline 함수를 도입해야 할 경우 도입했을 때의 장점을 설명해주고, 부작용을 방지할 수 있는 몇가지 방법(crossinline, noinline)들도 제시해주고 있다.<br>

<br>



# `inline` 함수란?

[github.com/study-kopring/grammar/인라인함수.md](https://github.com/gosgjung/study-kopring/blob/main/grammar/%EC%9D%B8%EB%9D%BC%EC%9D%B8%20%ED%95%A8%EC%88%98.md) 에서 세부적인 개념들은 정리해뒀다.<br>

여기서는 굉장히 단적인 예만 정리해보면 아래와 같다.

아래와 같은 `repeat` 이라는 inline 함수가 있다고 해보자.

```kotlin
inline fun repeat (times: Int, action: (Int) -> Unit){
    for (index in 0 until times){
        action(index)
    }
}
```

<br>



그리고 이렇게 정의한 `inline` 함수인 `repeat` 함수는 main문에서 아래와 같이 사용하고 있다.

```kotlin
fun main(){
    repeat(10){	// 함수의 가장 마지막 파라미터가 람다일 경우 '{...}'으로 묶어서 밖으로 빼낼수 있다.
        print(it)
    }
}
```

<br>



위의 코드는 컴파일 시점에 아래와 같이 대치된다.

```kotlin
for (index in 0 until 10){
    print(index)
}
```

<br>



# 일반 함수에 비해 `inline` 함수를 사용할 경우의 장점

일반함수 사용시 함수 본문으로 점프하고, 본문의 모든 문장을 호출한 뒤에 호출했던 위치로 다시 점프하는 과정을 거친다.<br>

하지만, inline 함수를 사용해서 '함수를 호출하는 부분'을 '함수의 본문'으로 대체하면 이러한 점프가 일어나지 않는다.<br>

inline 함수를 사용하면 아래의 장점들을 가진다.

- 타입 아규먼트에 reified 한정자를 붙여서 사용할 수 있다.
- 함수 타입 파라미터를 가진 함수를 inline 함수로 정의하면 훨씬 빠르게 동작한다.
- 비지역(non-local) 리턴을 사용할수 있다.

<br>



## 장점 1) 타입 아규먼트를 reified로 사용할 수 있다.

함수를 파라미터로 넘길때 inline 함수에 넘기는 것이 아니라면, 함수 객체로 넘어간다.<br>

객체에 대해서 특정 변수가 어떤 타입인지 확인 하는 코드를 사용할 수 없다.<br>

하지만, inline 함수를 정의하면 타입 아규먼트를 reified로 사용할 수 있다.<br>

reified 키워드를 통해 타입을 한정하는 것은 굉장히 유용하다.<br>

<br>

inline 함수를 사용할 때 inline 함수가 컴파일 타임에 번역된다는 것을 이용해 함수타입 파라미터에 `reified` 한정자를 붙이면 타입 파라미터를 사용한 부분이 타입 아규먼트로 대체된다.<br>

<br>

예를 들면 표준 라이브러리의 `filterIsInstance` 함수도 특정 타입의 요소를 필터링할 때 reified를 사용한다. <br>

```kotlin
class Worker
class Manager

val employees: List<Any> = listOf(Worker(), Manager(), Worker())

val workers: List<Worker> = employees.filterIsInstance<Worker>()
```

<br>



**JVM 바이트 코드의 제네릭 미지원**<br>

JVM 바이트 코드에는 제네릭이 존재하지 않는다. 이런 이유로 컴파일을 하면 제네릭 타입과 관련된 내용이 제거된다. 예를 들어 List\<Int\> 를 컴파일하면 List 로 바뀐다. 따라서 객체가 List 타입인지 확인하는 코드는 사용할 수 있지만, 객체가 List\<Int\> 인지 확인하는 코드는 사용할 수 없다.<br>

> J2SE 5.0(2004년) 버전 부터 자바에서 제네릭을 사용할 수 있게 되었지만, JVM 바이트 코드에는 제네릭이 존재하지 않는다.<br>

<br>

```kotlin
any is List<Int>  	// 에러
any is List<*> 		// ok
```

<br>

또한 타입 파라미터에 대한 연산도 오류가 발생한다.<br>

아래의 함수가 있다고 해보자. 이 코드는 에러를 낸다.<br>

JVM이 제네릭을 지원하지 않기에 클레스의 simpleName을 print 하려 할 때 에러를 낸다.<br>

```kotlin
fun <T> printTypeName(){
    print(T::class.simpleName) // 오류
}
```

<br>

**함수를 inline 으로 만들면 reified 한정자를 붙일수 있는데, 이때 타입 아규먼트 변환이 가능하다.**<br>

하지만 함수를 인라인으로 만들면 reified 한정자를 붙일 수 있기에, 컴파일 타임에 타입 파라미터를 사용한 부분이 타입 아규먼트로 대체된다.

```kotlin
inline fun <reified T> printTypeName(){
    print(T::class.simpleName)
}

// 사용 시에는 아래와 같이 
printTypeName<Int>()
printTypeName<Char>()
printTypeName<String>()
```

<br>

위의 코드들은 아래와 같이 대체된다.

```kotlin
print(Int::class.simpleName)	// Int
print(Char::class.simpleName)	// Char
print(String::class.simpleName)	// String
```

<br>



## 장점 2) 함수 타입 파라미터를 가진 함수를 inline 함수로 정의하면 훨씬 빠르게 동작한다.





## 장점 3) 비지역(non-local) 리턴을 사용할 수 있다.





# inline 함수를 사용하면 안좋은 경우들

- 재귀
- 수없이 많은 inline 함수 호출



# crossinline, noinline







